use bb8_postgres::tokio_postgres::{types::ToSql, Error};
use crossbeam_channel::{unbounded, Receiver, Sender};
use nanoid::nanoid;
use once_cell::sync::Lazy;
use serde::{Deserialize, Serialize};
use tokio::task;

use crate::app::database::{postgres::PostgresDatabase, redis::RedisDatabase};

/// `SenderType` is an enumeration used to specify the category of data being
/// sent in a system.
///
/// It's designed to identify the nature of the information or the context
/// within which the sending operation is performed.
///
/// This enum plays a crucial role in systems where different types of data
/// are handled and routed differently, ensuring that each sending operation
/// is associated with its appropriate category for effective processing and
/// management.
#[derive(Clone, Copy)]
pub enum SenderType {
    Permission,
    Role,
    User,
}

impl SenderType {
    pub fn to_string(&self) -> String {
        match self {
            SenderType::Permission => return String::from("permission_req"),
            SenderType::Role => return String::from("role_req"),
            SenderType::User => return String::from("user_req"),
        }
    }
}

/// Struct to encapsulate a message being sent, along with information about
/// the sender.
///
/// `SenderMessage` is designed to hold details pertinent to a message-sending
/// operation within a system. It includes the identity of the sender, the type
/// of sender as categorized by the `SenderType` enum, and the actual message content.
///
/// This struct is particularly useful in communication systems or message processing
/// applications where it's important to track not just the message content, but also
/// the source and nature of the message.
pub struct SenderMessage {
    sender_id: String,
    sender_type: SenderType,
    sender_message: String,
}

impl SenderMessage {
    /// Composes a `SenderMessage` from the provided `sender_type` and `sender_message`.
    ///
    /// This function serializes the `sender_message` of generic type `T` into a JSON string.
    /// It generates a unique sender-specific ID for the message and assigns it along with the
    /// `sender_type` and serialized message to the `SenderMessage`.
    ///
    /// # Type Parameters
    ///
    /// * `T` - A type that implements both `Deserialize` and `Serialize`.
    ///
    /// # Arguments
    ///
    /// * `sender_type` - The type of the sender.
    /// * `sender_message` - The message to be sent, of type `T`.
    ///
    /// # Returns
    ///
    /// Returns a new instance of `SenderMessage`.
    ///
    /// # Panics
    ///
    /// Panics if serialization of the `sender_message` fails.
    pub fn compose<T: for<'a> Deserialize<'a> + Serialize>(
        sender_type: SenderType,
        sender_message: T,
    ) -> SenderMessage {
        SenderMessage {
            sender_id: Self::generate_sender_specific_id(sender_type),
            sender_type,
            sender_message: serde_json::to_string(&sender_message).unwrap(),
        }
    }

    /// Generates a sender-specific ID based on the given `sender_type`.
    ///
    /// The ID is a combination of the `sender_type` string representation and a unique
    /// identifier generated by `nanoid!`.
    ///
    /// # Arguments
    ///
    /// * `sender_type` - The type of the sender for which the ID is being generated.
    ///
    /// # Returns
    ///
    /// Returns a `String` representing the unique sender-specific ID.
    fn generate_sender_specific_id(sender_type: SenderType) -> String {
        format!("{}-{}", sender_type.to_string(), nanoid!())
    }
}

/// `WorkerType` is an enumeration that categorizes workers into distinct
/// functional roles within a system.
///
/// It distinguishes between two primary types of workers: `Sender`,
/// indicating a worker that primarily handles sending operations, and
/// `Receiver`, indicating a worker focused on receiving tasks or messages.
///
/// his differentiation is crucial in systems involving message passing,
/// task distribution, or any scenario where workers have distinct operational
/// roles.
#[derive(PartialEq, Eq)]
pub enum WorkerType {
    Sender,
    Receiver,
}

/// Static channel for sending and receiving `SenderMessage` objects.
///
/// `TASK_CHANNEL` is a global communication channel, initialized lazily,
/// used for transmitting `SenderMessage` instances between different parts
/// of the application.
///
/// It consists of a tuple containing both the `Sender` and `Receiver` ends
/// of an unbounded asynchronous channel.
///
/// The channel uses `Lazy` to ensure thread-safe, one-time initialization.
/// The `unbounded()` function creates a channel without any capacity constraints,
/// allowing an unlimited number of messages to be sent before being received.
///
/// This channel is particularly useful in concurrent applications where different
/// components or threads need to communicate `
static TASK_CHANNEL: Lazy<(Sender<SenderMessage>, Receiver<SenderMessage>)> =
    Lazy::new(|| unbounded());

/// `WorkerManager` is a struct designed to facilitate database interactions in
/// worker-related functionalities. It combines connections to both a PostgreSQL
/// database (`pg`) and a Redis database (`redis`), catering to different data
/// management needs.
///
/// While the PostgreSQL connection is ideal for SQL-based operations, Redis serves
/// fast, in-memory data storage purposes. This struct streamlines the process of
/// integrating and managing multiple database systems within an application, especially
/// in scenarios involving complex worker data and processes.
pub struct WorkerManager {
    pg: PostgresDatabase,
    redis: RedisDatabase,
}

impl WorkerManager {
    /// Creates a new instance of `WorkerManager` with specified PostgreSQL and Redis database connections.
    ///
    /// This function initializes the `WorkerManager` with database connections, allowing it to
    /// interact with these databases as part of its operations. It's particularly useful for
    /// setting up a `WorkerManager` with the necessary database resources for task handling.
    ///
    /// # Arguments
    ///
    /// * `pg` - A `PostgresDatabase` connection to be used by the `WorkerManager`.
    /// * `redis` - A `RedisDatabase` connection to be used by the `WorkerManager`.
    ///
    /// # Returns
    ///
    /// Returns a new instance of `WorkerManager` configured with the specified database connections.
    pub fn with_databases(pg: PostgresDatabase, redis: RedisDatabase) -> WorkerManager {
        WorkerManager { pg, redis }
    }

    /// Starts a listener for incoming messages on the global task channel.
    ///
    /// This function spawns a new asynchronous task that continuously listens for messages
    /// sent to the `TASK_CHANNEL`. Upon receiving a message, it matches the `sender_type`
    /// field of the message and performs actions based on the type of sender. Currently,
    /// it handles `SenderType::User` by printing a message, while `SenderType::Permission`
    /// and `SenderType::Role` have empty implementations.
    ///
    /// The listener runs indefinitely, processing each message in the order it's received.
    ///
    /// # Examples
    ///
    /// ```
    /// let worker = WorkerManager::new();
    /// worker.listen(); // Start listening for messages
    /// ```
    ///
    /// Note: This function does not return as it spawns a listener task that runs indefinitely.
    pub fn listen(&self) {
        task::spawn(async move {
            println!("[ARC] worker initialized, now listening to requests.");
            for message in TASK_CHANNEL.1.iter() {
                match message.sender_type {
                    SenderType::Permission => {
                        println!("received a permission message {}", message.sender_id)
                        // process and cache (local cache)
                    }
                    SenderType::Role => {
                        println!("received a role message {}", message.sender_id)
                        // process and cache (local cache)
                    }
                    SenderType::User => {
                        println!("received a user message {}", message.sender_id)
                        // process user and cache (redis)
                    }
                }
            }
        });
    }

    pub fn send(&self, sender_message: SenderMessage) {
        TASK_CHANNEL.0.send(sender_message).unwrap();
    }

    /// Asynchronously processes a SQL query with the provided parameters.
    ///
    /// This function prepares and executes a SQL query against a PostgreSQL database using
    /// a connection from the pool. It's an asynchronous function that awaits the preparation
    /// and execution of the query, making it suitable for use in async contexts.
    ///
    /// # Arguments
    ///
    /// * `query` - A string slice containing the SQL query to be executed.
    /// * `params` - A slice of references to objects that implement `ToSql` and `Sync`.
    ///   These are the parameters to be bound to the SQL query.
    ///
    /// # Returns
    ///
    /// Returns a `Result<u64, Error>` where:
    /// - `Ok(u64)` is the number of rows affected by the query.
    /// - `Err(Error)` is the error encountered during query execution.
    ///
    /// # Errors
    ///
    /// This function can return an error if:
    /// - Retrieving a connection from the pool fails.
    /// - Preparing the SQL statement fails.
    /// - Executing the query fails.
    ///
    /// # Examples
    ///
    /// ```
    /// async fn example_usage(worker: &WorkerManager) {
    ///     let query = "INSERT INTO my_table (col1, col2) VALUES ($1, $2)";
    ///     let params: &[&(dyn ToSql + Sync)] = &[&"value1", &123];
    ///     match worker.process_query(query, params).await {
    ///         Ok(rows) => println!("{} rows inserted", rows),
    ///         Err(e) => println!("Error executing query: {}", e),
    ///     }
    /// }
    /// ```
    async fn process_query(
        &self,
        query: &str,
        params: &[&(dyn ToSql + Sync)],
    ) -> Result<u64, Error> {
        let pool = self.pg.pool.get().await.unwrap();
        let stmt = pool.prepare(query).await.unwrap();
        pool.execute(&stmt, params).await
    }
}
